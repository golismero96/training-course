{"ast":null,"code":"'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useAnimatedProps;\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _useRefEffect = _interopRequireDefault(require(\"../Utilities/useRefEffect\"));\nvar _AnimatedEvent = require(\"./AnimatedEvent\");\nvar _NativeAnimatedHelper = _interopRequireDefault(require(\"./NativeAnimatedHelper\"));\nvar _AnimatedProps = _interopRequireDefault(require(\"./nodes/AnimatedProps\"));\nvar _react = require(\"react\");\nfunction useAnimatedProps(props) {\n  var _useReducer = (0, _react.useReducer)(function (count) {\n      return count + 1;\n    }, 0),\n    _useReducer2 = (0, _slicedToArray2.default)(_useReducer, 2),\n    scheduleUpdate = _useReducer2[1];\n  var onUpdateRef = (0, _react.useRef)(null);\n  var node = (0, _react.useMemo)(function () {\n    return new _AnimatedProps.default(props, function () {\n      return onUpdateRef.current == null ? void 0 : onUpdateRef.current();\n    });\n  }, [props]);\n  useAnimatedPropsLifecycle(node);\n  var refEffect = (0, _react.useCallback)(function (instance) {\n    node.setNativeView(instance);\n    onUpdateRef.current = function () {\n      if (process.env.NODE_ENV === 'test' || typeof instance !== 'object' || typeof (instance == null ? void 0 : instance.setNativeProps) !== 'function' || isFabricInstance(instance)) {\n        scheduleUpdate();\n      } else if (!node.__isNative) {\n        instance.setNativeProps(node.__getAnimatedValue());\n      } else {\n        throw new Error('Attempting to run JS driven animation on animated node ' + 'that has been moved to \"native\" earlier by starting an ' + 'animation with `useNativeDriver: true`');\n      }\n    };\n    var target = getEventTarget(instance);\n    var events = [];\n    for (var propName in props) {\n      var propValue = props[propName];\n      if (propValue instanceof _AnimatedEvent.AnimatedEvent && propValue.__isNative) {\n        propValue.__attach(target, propName);\n        events.push([propName, propValue]);\n      }\n    }\n    return function () {\n      onUpdateRef.current = null;\n      for (var _ref of events) {\n        var _ref2 = (0, _slicedToArray2.default)(_ref, 2);\n        var _propName = _ref2[0];\n        var _propValue = _ref2[1];\n        _propValue.__detach(target, _propName);\n      }\n    };\n  }, [props, node]);\n  var callbackRef = (0, _useRefEffect.default)(refEffect);\n  return [reduceAnimatedProps(node), callbackRef];\n}\nfunction reduceAnimatedProps(node) {\n  return Object.assign({}, node.__getValue(), {\n    collapsable: false\n  });\n}\nfunction useAnimatedPropsLifecycle(node) {\n  var prevNodeRef = (0, _react.useRef)(null);\n  var isUnmountingRef = (0, _react.useRef)(false);\n  (0, _react.useEffect)(function () {\n    _NativeAnimatedHelper.default.API.flushQueue();\n  });\n  (0, _react.useLayoutEffect)(function () {\n    isUnmountingRef.current = false;\n    return function () {\n      isUnmountingRef.current = true;\n    };\n  }, []);\n  (0, _react.useLayoutEffect)(function () {\n    node.__attach();\n    if (prevNodeRef.current != null) {\n      var prevNode = prevNodeRef.current;\n      prevNode.__restoreDefaultValues();\n      prevNode.__detach();\n      prevNodeRef.current = null;\n    }\n    return function () {\n      if (isUnmountingRef.current) {\n        node.__detach();\n      } else {\n        prevNodeRef.current = node;\n      }\n    };\n  }, [node]);\n}\nfunction getEventTarget(instance) {\n  return typeof instance === 'object' && typeof (instance == null ? void 0 : instance.getScrollableNode) === 'function' ? instance.getScrollableNode() : instance;\n}\nfunction isFabricInstance(instance) {\n  var _instance$getScrollRe;\n  return hasFabricHandle(instance) || hasFabricHandle(instance == null ? void 0 : instance.getNativeScrollRef == null ? void 0 : instance.getNativeScrollRef()) || hasFabricHandle(instance == null ? void 0 : instance.getScrollResponder == null ? void 0 : (_instance$getScrollRe = instance.getScrollResponder()) == null ? void 0 : _instance$getScrollRe.getNativeScrollRef == null ? void 0 : _instance$getScrollRe.getNativeScrollRef());\n}\nfunction hasFabricHandle(instance) {\n  var _instance$_internalIn, _instance$_internalIn2;\n  return (instance == null ? void 0 : (_instance$_internalIn = instance['_internalInstanceHandle']) == null ? void 0 : (_instance$_internalIn2 = _instance$_internalIn.stateNode) == null ? void 0 : _instance$_internalIn2.canonical) != null;\n}","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","useAnimatedProps","_slicedToArray2","_useRefEffect","_AnimatedEvent","_NativeAnimatedHelper","_AnimatedProps","_react","props","_useReducer","useReducer","count","_useReducer2","scheduleUpdate","onUpdateRef","useRef","node","useMemo","AnimatedProps","current","useAnimatedPropsLifecycle","refEffect","useCallback","instance","setNativeView","process","env","NODE_ENV","setNativeProps","isFabricInstance","__isNative","__getAnimatedValue","Error","target","getEventTarget","events","propName","propValue","AnimatedEvent","__attach","push","_ref","_ref2","__detach","callbackRef","useRefEffect","reduceAnimatedProps","assign","__getValue","collapsable","prevNodeRef","isUnmountingRef","useEffect","NativeAnimatedHelper","API","flushQueue","useLayoutEffect","prevNode","__restoreDefaultValues","getScrollableNode","_instance$getScrollRe","hasFabricHandle","getNativeScrollRef","getScrollResponder","_instance$_internalIn","_instance$_internalIn2","stateNode","canonical"],"sources":["E:/Projects/learning/training_course/ReactNative/MyTestApp/node_modules/react-native/Libraries/Animated/useAnimatedProps.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\n'use strict';\n\nimport useRefEffect from '../Utilities/useRefEffect';\nimport {AnimatedEvent} from './AnimatedEvent';\nimport NativeAnimatedHelper from './NativeAnimatedHelper';\nimport AnimatedProps from './nodes/AnimatedProps';\nimport {\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useReducer,\n  useRef,\n} from 'react';\n\ntype ReducedProps<TProps> = {\n  ...TProps,\n  collapsable: boolean,\n  ...\n};\ntype CallbackRef<T> = T => mixed;\n\nexport default function useAnimatedProps<TProps: {...}, TInstance>(\n  props: TProps,\n): [ReducedProps<TProps>, CallbackRef<TInstance | null>] {\n  const [, scheduleUpdate] = useReducer<number, void>(count => count + 1, 0);\n  const onUpdateRef = useRef<?() => void>(null);\n\n  // TODO: Only invalidate `node` if animated props or `style` change. In the\n  // previous implementation, we permitted `style` to override props with the\n  // same name property name as styles, so we can probably continue doing that.\n  // The ordering of other props *should* not matter.\n  const node = useMemo(\n    () => new AnimatedProps(props, () => onUpdateRef.current?.()),\n    [props],\n  );\n  useAnimatedPropsLifecycle(node);\n\n  // TODO: This \"effect\" does three things:\n  //\n  //   1) Call `setNativeView`.\n  //   2) Update `onUpdateRef`.\n  //   3) Update listeners for `AnimatedEvent` props.\n  //\n  // Ideally, each of these would be separat \"effects\" so that they are not\n  // unnecessarily re-run when irrelevant dependencies change. For example, we\n  // should be able to hoist all `AnimatedEvent` props and only do #3 if either\n  // the `AnimatedEvent` props change or `instance` changes.\n  //\n  // But there is no way to transparently compose three separate callback refs,\n  // so we just combine them all into one for now.\n  const refEffect = useCallback(\n    (instance: TInstance) => {\n      // NOTE: This may be called more often than necessary (e.g. when `props`\n      // changes), but `setNativeView` already optimizes for that.\n      node.setNativeView(instance);\n\n      // NOTE: This callback is only used by the JavaScript animation driver.\n      onUpdateRef.current = () => {\n        if (\n          process.env.NODE_ENV === 'test' ||\n          typeof instance !== 'object' ||\n          typeof instance?.setNativeProps !== 'function' ||\n          isFabricInstance(instance)\n        ) {\n          // Schedule an update for this component to update `reducedProps`,\n          // but do not compute it immediately. If a parent also updated, we\n          // need to merge those new props in before updating.\n          scheduleUpdate();\n        } else if (!node.__isNative) {\n          // $FlowIgnore[not-a-function] - Assume it's still a function.\n          // $FlowFixMe[incompatible-use]\n          instance.setNativeProps(node.__getAnimatedValue());\n        } else {\n          throw new Error(\n            'Attempting to run JS driven animation on animated node ' +\n              'that has been moved to \"native\" earlier by starting an ' +\n              'animation with `useNativeDriver: true`',\n          );\n        }\n      };\n\n      const target = getEventTarget(instance);\n      const events = [];\n\n      for (const propName in props) {\n        const propValue = props[propName];\n        if (propValue instanceof AnimatedEvent && propValue.__isNative) {\n          propValue.__attach(target, propName);\n          events.push([propName, propValue]);\n        }\n      }\n\n      return () => {\n        onUpdateRef.current = null;\n\n        for (const [propName, propValue] of events) {\n          propValue.__detach(target, propName);\n        }\n      };\n    },\n    [props, node],\n  );\n  const callbackRef = useRefEffect<TInstance>(refEffect);\n\n  return [reduceAnimatedProps<TProps>(node), callbackRef];\n}\n\nfunction reduceAnimatedProps<TProps>(\n  node: AnimatedProps,\n): ReducedProps<TProps> {\n  // Force `collapsable` to be false so that the native view is not flattened.\n  // Flattened views cannot be accurately referenced by the native driver.\n  return {\n    ...node.__getValue(),\n    collapsable: false,\n  };\n}\n\n/**\n * Manages the lifecycle of the supplied `AnimatedProps` by invoking `__attach`\n * and `__detach`. However, this is more complicated because `AnimatedProps`\n * uses reference counting to determine when to recursively detach its children\n * nodes. So in order to optimize this, we avoid detaching until the next attach\n * unless we are unmounting.\n */\nfunction useAnimatedPropsLifecycle(node: AnimatedProps): void {\n  const prevNodeRef = useRef<?AnimatedProps>(null);\n  const isUnmountingRef = useRef<boolean>(false);\n\n  useEffect(() => {\n    // It is ok for multiple components to call `flushQueue` because it noops\n    // if the queue is empty. When multiple animated components are mounted at\n    // the same time. Only first component flushes the queue and the others will noop.\n    NativeAnimatedHelper.API.flushQueue();\n  });\n\n  useLayoutEffect(() => {\n    isUnmountingRef.current = false;\n    return () => {\n      isUnmountingRef.current = true;\n    };\n  }, []);\n\n  useLayoutEffect(() => {\n    node.__attach();\n    if (prevNodeRef.current != null) {\n      const prevNode = prevNodeRef.current;\n      // TODO: Stop restoring default values (unless `reset` is called).\n      prevNode.__restoreDefaultValues();\n      prevNode.__detach();\n      prevNodeRef.current = null;\n    }\n    return () => {\n      if (isUnmountingRef.current) {\n        // NOTE: Do not restore default values on unmount, see D18197735.\n        node.__detach();\n      } else {\n        prevNodeRef.current = node;\n      }\n    };\n  }, [node]);\n}\n\nfunction getEventTarget<TInstance>(instance: TInstance): TInstance {\n  return typeof instance === 'object' &&\n    typeof instance?.getScrollableNode === 'function'\n    ? // $FlowFixMe[incompatible-use] - Legacy instance assumptions.\n      instance.getScrollableNode()\n    : instance;\n}\n\n// $FlowFixMe[unclear-type] - Legacy instance assumptions.\nfunction isFabricInstance(instance: any): boolean {\n  return (\n    hasFabricHandle(instance) ||\n    // Some components have a setNativeProps function but aren't a host component\n    // such as lists like FlatList and SectionList. These should also use\n    // forceUpdate in Fabric since setNativeProps doesn't exist on the underlying\n    // host component. This crazy hack is essentially special casing those lists and\n    // ScrollView itself to use forceUpdate in Fabric.\n    // If these components end up using forwardRef then these hacks can go away\n    // as instance would actually be the underlying host component and the above check\n    // would be sufficient.\n    hasFabricHandle(instance?.getNativeScrollRef?.()) ||\n    hasFabricHandle(instance?.getScrollResponder?.()?.getNativeScrollRef?.())\n  );\n}\n\n// $FlowFixMe[unclear-type] - Legacy instance assumptions.\nfunction hasFabricHandle(instance: any): boolean {\n  // eslint-disable-next-line dot-notation\n  return instance?.['_internalInstanceHandle']?.stateNode?.canonical != null;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}